{namespace cxx_library}

/***/
{template .soyweb}
  {call buck.page}
    {param title: 'cxx_library()' /}
    {param prettify: true /}
    {param description}
      A cxx_library() rule represents a set of C/C++ source files.
    {/param}
    {param content}

{call buck.rule}
{param status: 'UNFROZEN' /}
{param overview}
A cxx_library() rule represents a set of C/C++ source files and provides various flags to control
how they get built. Other than that, C/C++ libraries by themselves are relatively abstract, and it's
dependent on the various top-level targets (e.g. C/C++ binary, Android APK) that transitively depend
on this rule how this library actually gets built (e.g. a C/C++ binary will require a static non-PIC
build of the library, while an Android APK will require a shared PIC-enabled build).
{/param}

{param args}

{call buck.arg}
  {param name: 'name' /}
  {param desc}
  The name of the rule.
  {/param}
{/call}

{call cxx_common.srcs_arg /}

{call cxx_common.platform_srcs_arg /}

{call cxx_common.headers_arg /}

{call cxx_common.platform_headers_arg /}

{call cxx_common.exported_headers_arg /}

{call cxx_common.platform_exported_headers_arg /}

{call cxx_common.header_namespace_arg /}

{call cxx_common.preprocessor_flags_arg /}

{call cxx_common.platform_preprocessor_flags_arg /}

{call cxx_common.exported_preprocessor_flags_arg /}

{call cxx_common.exported_platform_preprocessor_flags_arg /}

{call cxx_common.compiler_flags_arg /}

{call cxx_common.platform_compiler_flags_arg /}

{call cxx_common.linker_flags_arg /}

{call cxx_common.platform_linker_flags_arg /}

{call cxx_common.exported_linker_flags_arg /}

{call buck.arg}
  {param name : 'exported_platform_linker_flags' /}
  {param default : '[]' /}
  {param desc}
  Platform specific linker flags. These should be specified as a list of pairs where the first
  element is an un-anchored regex (in java.util.regex.Pattern syntax) against which the platform
  name is matched, and the second element is a list of flags to use when the target and all targets
  that transitively depend on it are involved in a link operation if the platform matches the regex.
  See <code>exported_linker_flags</code> for more information.
  {/param}
{/call}

{call cxx_common.link_style /}

{call buck.arg}
  {param name : 'supported_platforms_regex' /}
  {param default : 'None' /}
  {param desc}
  If present, an un-anchored regex (in java.util.regex.Pattern syntax) that matches all platforms
  that this library supports. It will not be built for other platforms. (Currently, this is only
  respected by android_binary and ndk_library.)
  {/param}
{/call}

{call buck.arg}
  {param name : 'force_static' /}
  {param default: 'false' /}
  {param desc}
  If <code>true</code>, the library will always be linked statically, even if the target that
  depends on it specifies <code>link_style</code> to be something other than <code>static</code>.
  Note this will cause duplicate symbols if multiple targets that depend on the library are linked
  together.
  {/param}
{/call}

{call buck.tests_arg /}

{call buck.visibility_arg /}

{/param} // close args

{param examples}
{literal}<pre class="prettyprint lang-py">
# A rule that includes a single .cpp file and its corresponding header and
# also supplies an additional flag for compilation.
cxx_library(
  name = 'fileutil',
  srcs = [
    'fileutil.cpp',
  ],
  exported_headers = [
    'fileutil.h',
  ],
  compiler_flags = [
    '-fno-omit-frame-pointer',
  ],
)

# A rule that defines explicit names for its headers
cxx_library(
  name = 'mathutils',
  header_namespace = 'math',
  srcs = [
    'trig/src/cos.cpp',
    'trig/src/tan.cpp',
  ],
  exported_headers = {
    # These are included as &lt;math/trig/cos.h&gt; and &lt;math/trig/tan.h&gt;
    'trig/cos.h': 'trig/include/cos.h',
    'trig/tan.h': 'trig/include/tan.h',
  },
  compiler_flags = [
    '-fno-omit-frame-pointer',
  ],
)

# A rule that uses different headers and sources per platform
cxx_library(
  name = 'vector',
  # Because of platform_headers, this file can include "config.h"
  # and get the architecture specific header
  srcs = ['vector.cpp'],
  platform_srcs = [
    ('.*armv7$', 'armv7.S'),
    ('.*x86_64$', 'x86_64.S'),
  ],
  exported_headers = [
    'vector.h',
  ],
  platform_headers = [
    (
      '.*armv7$',
      {
        'config.h': 'config-armv7.h',
      }
    ),
    (
      '.*x86_64$',
      {
        'config.h': 'config-x86_64.h',
      }
    ),
  ],
)

</pre>{/literal}
{/param}

{/call} // close buck.rule

    {/param}
  {/call}
{/template}
